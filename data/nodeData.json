{
  "version": "1.0.0",
  "menus": [
    {
      "id": "308d3e53-0f85-4f3b-b2e1-e073bd0acf6f",
      "title": "LiteGraph",
      "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f",
      "content": {
        "title": "LiteGraph",
        "content": "# LiteGraph\n是一个开源的 JavaScript 库，用于在浏览器中创建类似虚幻引擎蓝图（Unreal Blueprints）或 Pure Data 的可视化节点图（Node Graph）系统。它通过 HTML5 Canvas2D 渲染，提供了一个直观的图形化编辑器，允许用户通过拖拽节点和连接线来构建复杂的工作流或交互逻辑。LiteGraph 不仅支持客户端运行，还可以通过 Node.js 在服务器端执行（部分节点如音频、图形等可能受限）。它允许将图形导出为 JSON 格式，以便在应用程序中独立使用。\n\n### LiteGraph的作用\n\n. 是一个轻量级、灵活且功能强大的工具，广泛应用于以下场景：\n\n. 可视化工作流设计：\n用户可以通过拖拽节点和连接线快速构建复杂的工作流，适用于游戏开发、数据可视化、交互式叙事等领域。\n例如，可以创建用于图像处理、音频处理或逻辑控制的节点图，简化复杂逻辑的可视化表达。\n\n. 交互式界面开发：\n提供实时模式（Live Mode），隐藏节点图但调用节点渲染内容，适合创建动态用户界面（UI）。\n支持小部件（Widgets）节点，用于构建交互式控件，如按钮、滑块等。\n\n. 数学和逻辑运算：\n内置数学节点（如三角函数、基本运算）和逻辑节点，适合处理数值计算或条件判断。\n示例：通过定义一个求和节点（如 MyAddNode），用户可以轻松实现两个输入值的加法运算。\n\n. 跨平台支持：\n既可在浏览器中运行，也可在 Node.js 环境中执行（部分功能受限），适合多种开发场景。\n支持将节点图导出为 JSON，方便在不同项目中复用。\n\n. 高度可定制：\n用户可以轻松创建自定义节点类型，通过 LiteGraph.registerNodeType 注册新节点。例如，定义一个节点处理特定事件（如播放、暂停）或自定义逻辑。\n支持自定义主题（颜色、形状、背景）、插槽方向（垂直/水平）以及节点外观和行为。\n\n. 优化性能：\n设计上支持每个图形包含数百个节点，适用于复杂项目，同时在编辑和执行时保持高效。\n\nLiteGraph 是一个功能强大且灵活的 JavaScript 库，适合快速构建可视化工作流和交互式应用。其基于节点的编程模型和 Canvas2D 渲染使其在游戏开发、数据可视化和 UI 设计中具有广泛应用潜力。尽管在扩展性和 UI 渲染方面存在一定局限，但其轻量级设计和易用性使其成为低代码开发的理想选择。开发者可以通过自定义节点和 JSON 导出功能，进一步扩展其功能以满足特定需求。"
      },
      "children": [
        {
          "id": "ebb3fe34-fd2e-4726-8f6f-479c275ef13f",
          "title": "LGraphNode",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/ebb3fe34-fd2e-4726-8f6f-479c275ef13f",
          "content": {
            "title": "LGraphNode",
            "content": "节点的基础类，每个节点代表一个功能模块，包含输入/输出端口和可配置属性。"
          },
          "children": []
        },
        {
          "id": "292b8f4b-9e4a-48e3-829d-7bd37f4ad35e",
          "title": "LGraph",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/292b8f4b-9e4a-48e3-829d-7bd37f4ad35e",
          "content": {
            "title": "LGraph",
            "content": "整个节点的容器，管理节点和连接。"
          },
          "children": []
        },
        {
          "id": "ce29ebba-5a50-4879-bd73-8e911a12aa4e",
          "title": "LGraphCanvas",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/ce29ebba-5a50-4879-bd73-8e911a12aa4e",
          "content": {
            "title": "LGraphCanvas",
            "content": "负责在浏览器中渲染和交互的类，使用 Canvas2D 支持缩放、平移等操作。"
          },
          "children": []
        },
        {
          "id": "7ddf531c-33a4-44bf-a4aa-775338ae13fd",
          "title": "LiteGraph.Editor",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/7ddf531c-33a4-44bf-a4aa-775338ae13fd",
          "content": {
            "title": "LiteGraph.Editor",
            "content": "围绕 LGraphCanvas 的包装器，添加了按钮等 UI 元素以增强编辑体验。"
          },
          "children": []
        },
        {
          "id": "64f34135-63c9-4069-b264-2aa4d8103c51",
          "title": "class Attribute defintion",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/64f34135-63c9-4069-b264-2aa4d8103c51",
          "content": {
            "title": "class Attribute defintion",
            "content": "## 属性定义\n{\n  VERSION: 0.4, //版本\n  CANVAS_GRID_SIZE: 10, // 画布网格大小\n  NODE_TITLE_HEIGHT: 30, // 节点标题高度\n  NODE_TITLE_TEXT_Y: 20, // 节点标题文本 Y 坐标\n  NODE_WIDGET_HEIGHT: 20, // 节点组件高度\n  NODE_WIDTH: 140, // 节点宽度\n  NODE_MIN_WIDTH: 50, // 节点最小宽度\n  NODE_COLLAPSED_RADIUS: 10, // 节点折叠状态下的半径\n  NODE_COLLAPSED_WIDTH: 80, // 节点折叠状态下的宽度\n  NODE_TITLE_COLOR: \"#999\", // 节点标题颜色\n  NODE_SELECTED_TITLE_COLOR: \"#FFF\", // 选中节点的标题颜色\n  NODE_TEXT_SIZE: 14, // 节点文本大小\n  NODE_TEXT_COLOR: \"#AAA\", // 节点文本颜色\n  NODE_SUBTEXT_SIZE: 12, // 节点子文本大小\n  NODE_DEFAULT_COLOR: \"#333\", // 节点默认颜色\n  NODE_DEFAULT_BGCOLOR: \"#353535\", // 节点默认背景色\n  NODE_DEFAULT_BOXCOLOR: \"#666\", // 节点默认框颜色\n  NODE_DEFAULT_SHAPE: \"box\", // 节点默认形状\n  NODE_BOX_OUTLINE_COLOR: \"#FFF\", // 节点框轮廓颜色\n  DEFAULT_SHADOW_COLOR: \"rgba (0,0,0,0.5)\", // 默认阴影颜色\n  DEFAULT_GROUP_FONT: 24, // 默认组字体大小\n  WIDGET_BGCOLOR: \"#222\", // 组件背景色\n  WIDGET_OUTLINE_COLOR: \"#666\", // 组件轮廓颜色\n  WIDGET_TEXT_COLOR: \"#DDD\", // 组件文本颜色\n  WIDGET_SECONDARY_TEXT_COLOR: \"#999\", // 组件次要文本颜色\n  LINK_COLOR: \"#9A9\", // 普通连接线颜色\n  EVENT_LINK_COLOR: \"#A86\", // 事件连接线颜色\n  CONNECTING_LINK_COLOR: \"#AFA\", // 正在连接的连接线颜色\n  MAX_NUMBER_OF_NODES: 1000, // 最大节点数量，避免无限循环\n  DEFAULT_POSITION: [100, 100], // 默认节点位置\n  VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"], // 有效的形状 [\"默认\", \"方框\", \"圆角\", \"卡片\"]\n  // 形状用于节点也用于插槽\n  BOX_SHAPE: 1, // 方框形状\n  ROUND_SHAPE: 2, // 圆角形状\n  CIRCLE_SHAPE: 3, // 圆形形状\n  CARD_SHAPE: 4, // 卡片形状\n  ARROW_SHAPE: 5, // 箭头形状\n  GRID_SHAPE: 6, // 网格形状，用于插槽数组\n  \n  // 枚举类型\n  INPUT: 1, // 输入\n  OUTPUT: 2, // 输出\n  EVENT: -1, // 用于输出的事件\n  ACTION: -1, // 用于输入的动作\n  NODE_MODES: [\"Always\", \"On Event\", \"Never\", \"On Trigger\"],//[\"始终\", \"事件触发\", \"从不\", \"触发器触发\"], // 节点模式辅助说明，未来将添加 \"请求触发\" 等更多模式\n  NODE_MODES_COLORS:[\"#666\",\"#422\",\"#333\",\"#224\",\"#626\"], // 节点框按模式着色时使用的颜色\n  ALWAYS: 0, // 始终模式\n  ON_EVENT: 1, // 事件触发模式\n  NEVER: 2, // 从不模式\n  ON_TRIGGER: 3, // 触发器触发模式\n  \n  UP: 1, // 上\n  DOWN: 2, // 下\n  LEFT: 3, // 左\n  RIGHT: 4, // 右\n  CENTER: 5, // 中心\n\n  LINK_RENDER_MODES: [\"Straight\", \"Linear\", \"Spline\"],[\"直线\", \"折线\", \"曲线\"], // 连接线渲染模式辅助说明\n  STRAIGHT_LINK: 0, // 直线连接\n  LINEAR_LINK: 1, // 折线连接\n  SPLINE_LINK: 2, // 曲线连接\n  NORMAL_TITLE: 0, // 正常标题\n  NO_TITLE: 1, // 无标题\n  TRANSPARENT_TITLE: 2, // 透明标题\n  AUTOHIDE_TITLE: 3, // 自动隐藏标题\n  VERTICAL_LAYOUT: \"vertical\", // 垂直排列节点\n  proxy: null, // 用于重定向调用\n  node_images_path: \"\", // 节点图片路径\n  \n  debug: false, // 调试模式\n  catch_exceptions: true, // 捕获异常\n  throw_errors: true, // 抛出错误\n  allow_scripts: false, // 如果设为 true，像 Formula 这样的节点将被允许执行来自不安全来源（如节点配置）的代码，这可能导致漏洞\n  use_deferred_actions: true, // 在图执行流程中执行动作\n  registered_node_types: {}, // 按字符串索引的节点类型\n  node_types_by_file_extension: {}, // 用于在画布中拖放文件时使用\n  Nodes: {}, // 按类名索引的节点类型\n  Globals: {}, // 用于在图之间存储变量\n  searchbox_extras: {}, // 用于向搜索框添加额外功能\n  auto_sort_node_types: false, // 如果设为 true，将自动在上下文菜单中排序节点类型 / 类别\n  node_box_coloured_when_on: false, // 这使得节点框（左上角圆圈）在触发时（执行 / 动作）变色，提供视觉反馈\n  node_box_coloured_by_mode: false, // 节点框根据节点模式着色，提供视觉反馈\n  dialog_close_on_mouse_leave: true, // 在移动设备上为 false，如果不是触摸设备，设为 true 更好，TODO 添加辅助器 / 监听器在为 false 时关闭\n  dialog_close_on_mouse_leave_delay: 500, // 鼠标离开后对话框关闭延迟时间（毫秒）\n  shift_click_do_break_link_from: false, // 如果结果太容易断开链接，倾向于设为 false - 用 ALT 或 TODO 自定义键实现\n  click_do_break_link_to: false, // 倾向于设为 false，太容易断开链接\n  search_hide_on_mouse_leave: true, // 在移动设备上为 false，如果不是触摸设备，设为 true 更好，TODO 添加辅助器 / 监听器在为 false 时关闭\n  search_filter_enabled: false, // 启用搜索组件中的插槽类型过滤，! 需要 auto_load_slot_types 或手动设置 registered_slot_[in/out]types 和 slot_types[in/out]\n  search_show_all_on_open: true, // 打开搜索组件时显示所有结果列表\n  \n  auto_load_slot_types: false, // 如果不想要 false，用 true，运行，获取要静态设置的变量值，然后禁用] 需要计算节点类型和与节点类型的节点类关联，如果不想要这个，计算一次并设置 registered_slot_[in/out]types 和 slot_types[in/out]\n\n  // 如果不使用 auto_load_slot_types，设置这些值\n  registered_slot_in_types: {}, // 节点类的输入插槽类型\n  registered_slot_out_types: {}, // 节点类的输出插槽类型\n  slot_types_in: [], // 输入插槽类型\n  slot_types_out: [], // 输出插槽类型\n  slot_types_default_in: [], // 为每个输入插槽类型指定一个 / 多个默认节点，使用单个字符串、数组或对象（包含 node, title, parameters 等），如搜索中使用的\n  slot_types_default_out: [], // 为每个输出插槽类型指定一个 / 多个默认节点，使用单个字符串、数组或对象（包含 node, title, parameters 等），如搜索中使用的\n  alt_drag_do_clone_nodes: false, // 非常方便，按住 ALT 点击克隆并拖动新节点\n  do_add_triggers_slots: false, // 当使用动作 / 事件连接时，将创建并连接事件插槽，! 使用 onTrigger 时会改变节点模式（启用模式颜色），onExecuted 不需要这个\n  allow_multi_output_for_events: true, // 作为事件，强烈建议按顺序使用它们，一个接一个\n  middle_click_slot_add_default_node: false, // 允许使用第三个按钮（滚轮）点击创建并连接节点\n  release_link_on_empty_shows_menu: false, // 将链接拖到空白处会打开菜单，从列表中添加、搜索或使用默认值\n  pointerevents_method: \"mouse\", // \"mouse\"|\"pointer\" 为了向后兼容问题使用 mouse？（目前未发现问题）\n\n  // TODO 实现 pointercancel, gotpointercapture, lostpointercapture, (必要时 pointerover, pointerout)\n  ctrl_shift_v_paste_connect_unselected_outputs: false, // 允许 ctrl + shift + v 粘贴节点，同时将未选中节点的输出与新粘贴节点的输入连接\n  \n  // 如果为 true，所有新创建的节点 / 链接将使用字符串 UUID 作为其 id 字段，而不是整数。\n  // 如果必须使节点 ID 在所有图和子图中唯一，请使用此选项。  \n  use_uuids: false,\n}\n  \n\n  \n  \n"
          },
          "children": []
        },
        {
          "id": "87b75d38-8aaf-41b8-90c7-25a394348cfe",
          "title": "registerNodeType",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/87b75d38-8aaf-41b8-90c7-25a394348cfe",
          "content": {
            "title": "registerNodeType",
            "content": "## registerNodeType 方法注释分析\n\n  该方法是 LiteGraph 框架中用于注册节点类型的核心函数，作用是将自定义节点类纳入框架管理，使其可被用户创建和使用。以下从功能、参数、实现逻辑等方面详细分析：\n\n  ***方法功能概述***\n\n    registerNodeType 用于注册一个节点类，使其能在用户创建新节点时被列出和使用。通过该方法，框架会对节点类进行规范化处理（如继承基础节点方法、设置类型和分类等），并将其存储到全局注册表中，供后续调用。\n  ***参数说明***\n\n  . ***type（String）***：\n      节点的名称和路径（格式通常为 分类/节点名，如 math/add），用于标识节点类型并划分分类。\n  . ***base_class（Class）：***\n      包含节点结构的类（必须是带有原型的类），定义了节点的行为、属性、输入 / 输出插槽等。\n\n```\n         /**\n         * 注册一个节点类，这样当用户想要创建一个新的节点时，它可以被列出\n         * @method registerNodeType\n         * @param {String} 节点和路径的类型名称\n         * @param {Class} base_class类包含节点的结构\n         */\n\n        registerNodeType: function(type, base_class) {\n            if (!base_class.prototype) {\n                throw \"Cannot register a simple object, it must be a class with a prototype\";\n            }\n            base_class.type = type;\n\n            if (LiteGraph.debug) {\n                console.log(\"Node registered: \" + type);\n            }\n\n            const classname = base_class.name;\n\n            const pos = type.lastIndexOf(\"/\");\n            base_class.category = type.substring(0, pos);\n\n            if (!base_class.title) {\n                base_class.title = classname;\n            }\n\n            //extend class\n            for (var i in LGraphNode.prototype) {\n                if (!base_class.prototype[i]) {\n                    base_class.prototype[i] = LGraphNode.prototype[i];\n                }\n            }\n\n            const prev = this.registered_node_types[type];\n            if(prev) {\n                console.log(\"replacing node type: \" + type);\n            }\n            if( !Object.prototype.hasOwnProperty.call( base_class.prototype, \"shape\") ) {\n                Object.defineProperty(base_class.prototype, \"shape\", {\n                    set: function(v) {\n                        switch (v) {\n                            case \"default\":\n                                delete this._shape;\n                                break;\n                            case \"box\":\n                                this._shape = LiteGraph.BOX_SHAPE;\n                                break;\n                            case \"round\":\n                                this._shape = LiteGraph.ROUND_SHAPE;\n                                break;\n                            case \"circle\":\n                                this._shape = LiteGraph.CIRCLE_SHAPE;\n                                break;\n                            case \"card\":\n                                this._shape = LiteGraph.CARD_SHAPE;\n                                break;\n                            default:\n                                this._shape = v;\n                        }\n                    },\n                    get: function() {\n                        return this._shape;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                \n\n                //用于在将文件拖到画布时知道要创建哪些节点\n                if (base_class.supported_extensions) {\n                    for (let i in base_class.supported_extensions) {\n                        const ext = base_class.supported_extensions[i];\n                        if(ext && ext.constructor === String) {\n                            this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;\n                        }\n                    }\n                }\n            }\n\n            this.registered_node_types[type] = base_class;\n            if (base_class.constructor.name) {\n                this.Nodes[classname] = base_class;\n            }\n            if (LiteGraph.onNodeTypeRegistered) {\n                LiteGraph.onNodeTypeRegistered(type, base_class);\n            }\n            if (prev && LiteGraph.onNodeTypeReplaced) {\n                LiteGraph.onNodeTypeReplaced(type, base_class, prev);\n            }\n\n            //warnings\n            if (base_class.prototype.onPropertyChange) {\n                console.warn(\n                    \"LiteGraph node class \" +\n                        type +\n                        \" has onPropertyChange method, it must be called onPropertyChanged with d at the end\"\n                );\n            }\n            \n            // TODO one would want to know input and ouput :: this would allow through registerNodeAndSlotType to get all the slots types\n            if (this.auto_load_slot_types) {\n                new base_class(base_class.title || \"tmpnode\");\n            }\n        },\n```\n\n**核心实现逻辑**\n1.参数校验\n```\nif (!base_class.prototype) {\n    throw \"Cannot register a simple object, it must be a class with a prototype\";\n}\n```\n\n检查 base_class 是否为有效的类（必须有原型），若为普通对象则抛出错误，确保注册的是可实例化的节点类。\n\n2.基础属性赋值\n- 为节点类添加 type 属性，记录其唯一标识（即参数 type）。\n- 若开启调试模式（LiteGraph.debug），打印注册日志（Node registered: [type]）。\n- 提取节点类名（classname = base_class.name），作为节点标题的默认值。\n\n3.分类与标题设置\n```\nconst pos = type.lastIndexOf(\"/\");\nbase_class.category = type.substring(0, pos); // 从 type 中提取分类（如 \"math/add\" → 分类为 \"math\"）\nif (!base_class.title) {\n    base_class.title = classname; // 若未自定义标题，默认使用类名作为标题\n}\n\n```\n自动从 type 中解析分类（如 type 为 logic/compare 时，分类为 logic），并设置节点标题（优先使用类的 title 属性，否则 fallback 到类名）。\n\n4.继承基础节点方法\n```\nfor (var i in LGraphNode.prototype) {\n    if (!base_class.prototype[i]) {\n        base_class.prototype[i] = LGraphNode.prototype[i];\n    }\n}\n```\n\n将基础节点类 LGraphNode 的原型方法（如节点绘制、连接管理等）继承到当前节点类，确保自定义节点具备基础功能。\n\n5.处理节点形状（shape）\n为节点类原型添加 shape 属性的 getter/setter，支持通过字符串（如 \"box\"、\"round\"）设置节点形状，并映射到框架内部的形状枚举值（如 LiteGraph.BOX_SHAPE）。\n\n6.文件扩展名关联（可选）\n```\nif (base_class.supported_extensions) {\n    for (let i in base_class.supported_extensions) {\n        const ext = base_class.supported_extensions[i];\n        if(ext && ext.constructor === String) {\n            this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;\n        }\n    }\n}\n```\n\n若节点类定义了 supported_extensions（支持的文件扩展名数组），则将扩展名与节点类关联，用于在画布中拖放对应文件时自动创建该节点。\n\n7.注册到全局表\n将节点类存入 registered_node_types（按 type 索引），若存在同名节点则覆盖并打印警告。\n将节点类按类名存入 Nodes 字典，方便通过类名快速访问。\n\n8.事件回调\n若定义了 onNodeTypeRegistered 回调，注册完成后触发，通知外部节点已注册。\n若节点类型被覆盖（存在旧版本），触发 onNodeTypeReplaced 回调。\n\n9.兼容性警告\n```\nif (base_class.prototype.onPropertyChange) {\n    console.warn(\"... onPropertyChange must be called onPropertyChanged ...\");\n}\n\n```\n若节点类定义了 onPropertyChange 方法，警告用户应使用规范名称 onPropertyChanged（末尾多一个 d）。\n\n10.自动加载插槽类型（可选）\njavascript\nif (this.auto_load_slot_types) {\n    new base_class(base_class.title || \"tmpnode\");\n}\n\n\n若开启 auto_load_slot_types，通过实例化节点类，自动解析其输入 / 输出插槽类型，用于后续的类型过滤和默认节点关联。\n\n**关键作用**\n规范化节点类：确保所有注册的节点都继承基础节点功能，统一行为规范。\n管理节点注册表：集中存储节点类型，方便用户通过分类查找和创建节点。\n支持扩展功能：如文件拖放关联、插槽类型自动解析等，增强框架灵活性。\n\n**使用场景**\n当开发者自定义节点类（如实现一个数学计算节点或事件触发节点）后，需通过 registerNodeType 注册，才能在 LiteGraph 画布中使用该节点。例如：\n```\n// 定义自定义节点类\nclass AddNode { /* ... 节点逻辑 ... */ }\n\n// 注册节点类型（分类为 \"math\"，节点名为 \"add\"）\nLiteGraph.registerNodeType(\"math/add\", AddNode);\n\n```\n注册后，用户可在画布的上下文菜单中通过 math 分类找到并创建 add 节点。"
          },
          "children": []
        },
        {
          "id": "889f94b6-1e69-4bcb-998f-c53b28b8420c",
          "title": "unregisterNodeType",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/889f94b6-1e69-4bcb-998f-c53b28b8420c",
          "content": {
            "title": "unregisterNodeType",
            "content": "## unregisterNodeType 方法注释分析\n\n  该方法用于从系统中移除已注册的节点类型，是 registerNodeType 方法的反向操作，用于清理或更新节点类型注册信息。以下是详细解析：\n方法功能概述\nunregisterNodeType 用于从 LiteGraph 框架中注销指定的节点类型，使其不再可被用户创建或使用。通过该方法，框架会从全局注册表中移除对应的节点类信息，释放相关资源。\n**参数说明**\n. type（String | Object）：\n可以是两种形式：\n1. 字符串（String）：节点类型的唯一标识（即注册时使用的 type 参数，如 \"math/add\"）。\n2. 对象（Object）：节点类的构造函数本身（即注册时的 base_class）。\n```\n/ * *\n*从系统中删除节点类型\n@method unregisterNodeType\n@param {String|Object}节点或节点构造函数本身的类型名称\n* /\n  unregisterNodeType: function(type) {\n      const base_class =\n          type.constructor === String\n              ? this.registered_node_types[type]\n              : type;\n      if (!base_class) {\n          throw \"node type not found: \" + type;\n      }\n      delete this.registered_node_types[base_class.type];\n      if (base_class.constructor.name) {\n          delete this.Nodes[base_class.constructor.name];\n      }\n  }\n```"
          },
          "children": []
        },
        {
          "id": "e913b37f-7292-46b1-a334-61f2b4d25d8a",
          "title": "registerNodeAndSlotType",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/e913b37f-7292-46b1-a334-61f2b4d25d8a",
          "content": {
            "title": "registerNodeAndSlotType",
            "content": "## registerNodeAndSlotType 方法注释分析\n该方法是 LiteGraph 框架中用于注册节点类型与插槽（Slot）类型关联的工具函数，作用是建立节点类与输入 / 输出插槽类型的映射关系，方便后续对插槽类型进行过滤、搜索或自动关联默认节点。以下从功能、参数、实现逻辑等方面详细解析：\n\n**方法功能概述**\n\nregisterNodeAndSlotType 用于将节点类与特定的插槽类型（输入或输出）关联起来，通过该方法可以：\n1.记录节点类支持的输入 / 输出插槽类型；\n2.将插槽类型归类到全局列表中（便于后续过滤和展示）；\n3.建立 “插槽类型→节点类” 的映射关系，为搜索、自动连接等功能提供数据支持。\n\n**参数说明**\n\n1. type（String | Class）：\n    节点类型标识，可以是字符串（节点的 type 路径，如 \"math/add\"）或节点类本身（base_class），用于指定要关联的节点。\n2. slot_type（String | Number）：\n    插槽类型，可以是字符串（如 \"number\"、\"string\"）或框架枚举值（如 EVENT、ACTION），表示节点支持的插槽数据类型。\n3. out（Boolean，可选，默认 false）：\n    标识插槽类型是输出（true）还是输入（false），用于区分关联到输入插槽注册表还是输出插槽注册表。\n```\n  / * *\n  * 保存槽类型和他的节点\n  * @method registerSlotType\n  * @param {String|Object}节点或节点构造函数本身的类型名称\n  * @param {String} slot_type槽位类型的名称（变量类型），例如。字符串，数字，数组，布尔值，…\n  * /\n  registerNodeAndSlotType: function(type, slot_type, out){\n            out = out || false;\n        const base_class =\n            type.constructor === String &&\n            this.registered_node_types[type] !== \"anonymous\"\n                ? this.registered_node_types[type]\n                : type;\n\n        const class_type = base_class.constructor.type;\n\n        let allTypes = [];\n        if (typeof slot_type === \"string\") {\n            allTypes = slot_type.split(\",\");\n        } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n            allTypes = [\"_event_\"];\n        } else {\n            allTypes = [\"*\"];\n        }\n\n        for (let i = 0; i < allTypes.length; ++i) {\n            let slotType = allTypes[i];\n            if (slotType === \"\") {\n                slotType = \"*\";\n            }\n            const registerTo = out\n                ? \"registered_slot_out_types\"\n                : \"registered_slot_in_types\";\n            if (this[registerTo][slotType] === undefined) {\n                this[registerTo][slotType] = { nodes: [] };\n            }\n            if (!this[registerTo][slotType].nodes.includes(class_type)) {\n                this[registerTo][slotType].nodes.push(class_type);\n            }\n\n            // check if is a new type\n            if (!out) {\n                if (!this.slot_types_in.includes(slotType.toLowerCase())) {\n                    this.slot_types_in.push(slotType.toLowerCase());\n                    this.slot_types_in.sort();\n                }\n            } else {\n                if (!this.slot_types_out.includes(slotType.toLowerCase())) {\n                    this.slot_types_out.push(slotType.toLowerCase());\n                    this.slot_types_out.sort();\n                }\n            }\n        }\n    },\n```"
          },
          "children": []
        },
        {
          "id": "ce083bf4-c4d1-4d1f-b85c-b268a9ec91ff",
          "title": "buildNodeClassFramObject",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/ce083bf4-c4d1-4d1f-b85c-b268a9ec91ff",
          "content": {
            "title": "buildNodeClassFramObject",
            "content": "## buildNodeClassFromObject 方法注释分析\n该方法是 LiteGraph 框架中用于快速创建节点类型的工具函数，通过传入一个包含节点属性和方法的对象，动态生成节点类并自动注册。适用于快速定义简单节点，无需手动编写完整的类结构。\n方法功能概述\nbuildNodeClassFromObject 用于根据一个配置对象动态构建节点类，并自动注册到框架中。配置对象可包含节点的输入 / 输出插槽、属性、生命周期方法（如 onCreate、onExecute）等，方法会根据这些配置生成对应的类结构，最终通过 registerNodeType 完成注册。\n参数说明\nname（String）：\n节点的名称和命名空间（格式为 分类/节点名，如 math/sum），作为节点的唯一标识，同时用于注册和显示。\nobject（Object）：\n节点配置对象，包含节点的结构和行为定义，支持的关键属性如下：\ninputs（Array）：输入插槽列表，每个元素为 [名称, 类型]（如 [[\"a\", \"number\"], [\"b\", \"number\"]]）。\noutputs（Array）：输出插槽列表，格式同 inputs。\nproperties（Object）：节点属性键值对（如 { value: 0, label: \"结果\" }），用于存储节点的配置信息。\nonCreate（Function）：节点实例化时的初始化方法。\nonExecute（Function）：节点执行时的逻辑方法（如计算、数据处理）。\n其他自定义方法：如 onAction、onPropertyChanged 等，会被添加到节点类的原型中。\n\n```\n/ * *\n*通过传递一个带有一些属性的对象来创建一个新的节点类型\n*像onCreate，输入：数组，输出：数组，属性，onExecute\n* @method buildNodeClassFromObject\n* @param {String} name节点名称与命名空间（p.e: 'math/sum'）\n* @param {Object}对象方法预期onCreate，输入，输出，属性，onExecute\n* /\nbuildNodeClassFromObject: function(\n            name,\n            object\n        ) {\n            var ctor_code = \"\";\n            if(object.inputs)\n            for(var i=0; i < object.inputs.length; ++i)\n            {\n                var _name = object.inputs[i][0];\n                var _type = object.inputs[i][1];\n                if(_type && _type.constructor === String)\n                    _type = '\"'+_type+'\"';\n                ctor_code += \"this.addInput('\"+_name+\"',\"+_type+\");\\n\";\n            }\n            if(object.outputs)\n            for(var i=0; i < object.outputs.length; ++i)\n            {\n                var _name = object.outputs[i][0];\n                var _type = object.outputs[i][1];\n                if(_type && _type.constructor === String)\n                    _type = '\"'+_type+'\"';\n                ctor_code += \"this.addOutput('\"+_name+\"',\"+_type+\");\\n\";\n            }\n            if(object.properties)\n            for(var i in object.properties)\n            {\n                var prop = object.properties[i];\n                if(prop && prop.constructor === String)\n                    prop = '\"'+prop+'\"';\n                ctor_code += \"this.addProperty('\"+i+\"',\"+prop+\");\\n\";\n            }\n            ctor_code += \"if(this.onCreate)this.onCreate()\";\n            var classobj = Function(ctor_code);\n            for(var i in object)\n                if(i!=\"inputs\" && i!=\"outputs\" && i!=\"properties\")\n                    classobj.prototype[i] = object[i];\n            classobj.title = object.title || name.split(\"/\").pop();\n            classobj.desc = object.desc || \"Generated from object\";\n            this.registerNodeType(name, classobj);\n            return classobj;\n        },\n```\n**核心实现逻辑**\n1.生成构造函数代码字符串\n方法通过拼接字符串的方式，动态生成节点类的构造函数代码，用于初始化节点的输入 / 输出插槽和属性：\n```\nvar ctor_code = \"\";\n// 处理输入插槽：生成 addInput 调用代码\nif (object.inputs) {\n    for (var i = 0; i < object.inputs.length; ++i) {\n        var _name = object.inputs[i][0];\n        var _type = object.inputs[i][1];\n        if (_type && typeof _type === \"string\") _type = '\"' + _type + '\"'; // 字符串类型加引号\n        ctor_code += \"this.addInput('\" + _name + \"',\" + _type + \");\\n\";\n    }\n}\n// 处理输出插槽：生成 addOutput 调用代码\nif (object.outputs) {\n    for (var i = 0; i < object.outputs.length; ++i) {\n        var _name = object.outputs[i][0];\n        var _type = object.outputs[i][1];\n        if (_type && typeof _type === \"string\") _type = '\"' + _type + '\"';\n        ctor_code += \"this.addOutput('\" + _name + \"',\" + _type + \");\\n\";\n    }\n}\n// 处理属性：生成 addProperty 调用代码\nif (object.properties) {\n    for (var i in object.properties) {\n        var prop = object.properties[i];\n        if (prop && typeof prop === \"string\") prop = '\"' + prop + '\"';\n        ctor_code += \"this.addProperty('\" + i + \"',\" + prop + \");\\n\";\n    }\n}\n// 调用 onCreate 方法（若存在）\nctor_code += \"if(this.onCreate)this.onCreate()\";\n```\n上述代码的作用是将配置对象中的 inputs、outputs、properties 转换为节点构造函数中的初始化逻辑（通过 addInput、addOutput、addProperty 方法），并在最后调用 onCreate 方法（如果定义）\n\n2.动态生成节点类\n```\nvar classobj = Function(ctor_code);\n\n```\n通过 Function 构造函数将上述拼接的代码字符串转换为节点类的构造函数。例如，若 ctor_code 为 this.addInput('a', 'number');，则 classobj 是一个构造函数，实例化时会执行该代码。\n\n3.绑定原型方法\n```\nfor (var i in object) {\n    if (i !== \"inputs\" && i !== \"outputs\" && i !== \"properties\") {\n        classobj.prototype[i] = object[i];\n    }\n}\n```\n将配置对象中除 inputs、outputs、properties 外的属性（通常是方法，如 onExecute、onAction）绑定到节点类的原型上，使实例化的节点能继承这些方法。\n\n4.设置节点元信息\n```\nclassobj.title = object.title || name.split(\"/\").pop(); // 标题默认取名称的最后部分（如 \"sum\"）\nclassobj.desc = object.desc || \"Generated from object\"; // 描述默认值\n```\n\n5.注册节点类型\n```\nthis.registerNodeType(name, classobj);\n```\n调用 registerNodeType 方法将动态生成的节点类注册到框架中，使其可被用户创建和使用。\n\n6.返回节点类\n```\nreturn classobj;\n```\n返回生成的节点类，方便后续进一步操作（如扩展或存储）\n\n关键作用\n简化节点创建流程：无需手动编写完整的类定义，通过配置对象即可快速生成节点，降低开发门槛。\n标准化节点结构：自动处理输入 / 输出插槽、属性的初始化，确保节点符合框架规范。\n无缝集成注册流程：生成类后自动调用 registerNodeType，无需手动注册，提高开发效率。\n\n使用场景\n适用于快速定义简单节点，例如创建一个加法计算节点：\n```\n// 配置对象\nconst addConfig = {\n  inputs: [[\"a\", \"number\"], [\"b\", \"number\"]], // 两个数字输入\n  outputs: [[\"result\", \"number\"]], // 一个数字输出\n  onExecute: function() {\n    const a = this.getInputData(0);\n    const b = this.getInputData(1);\n    this.setOutputData(0, a + b); // 计算并输出结果\n  },\n  title: \"Add Numbers\", // 自定义标题\n  desc: \"Adds two numbers and outputs the result\"\n};\n\n// 生成并注册节点\nLiteGraph.buildNodeClassFromObject(\"math/add\", addConfig);\n\n```\n执行后，框架中会新增一个 math/add 节点，包含两个输入插槽、一个输出插槽，执行时会计算输入值的和并输出。\n注意事项\n该方法适用于简单节点，复杂节点（如需要复杂原型方法或继承逻辑）仍需手动定义类。\n配置对象中的方法（如 onExecute）的 this 指向节点实例，可直接调用节点的内置方法（如 getInputData、setOutputData）。\n生成的节点类会自动注册，无需再次调用 registerNodeType。\n"
          },
          "children": []
        },
        {
          "id": "3f58052c-f86c-489e-81c9-0d8cbf08e0a6",
          "title": "wrapFunctionAsnode",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/3f58052c-f86c-489e-81c9-0d8cbf08e0a6",
          "content": {
            "title": "wrapFunctionAsnode",
            "content": "## wrapFunctionAsNode 方法注释分析\n该方法是 LiteGraph 框架中用于将普通函数快速转换为节点类型的工具函数，通过自动生成输入 / 输出插槽和执行逻辑，实现函数与节点的无缝映射。适用于将简单处理函数（如数学计算、数据转换）封装为可视化节点，无需手动编写节点类。\n方法功能概述\nwrapFunctionAsNode 用于将一个普通函数包装为框架可识别的节点类型，核心功能包括：\n根据函数参数自动生成输入插槽；\n根据返回值定义输出插槽；\n自动生成 onExecute 方法，实现 “获取输入→调用函数→输出结果” 的逻辑；\n最终将生成的节点类注册到框架中，使其可在画布中使用。\n参数说明\nname（String）：\n节点的名称和命名空间（格式为 分类/节点名，如 math/sum），作为节点的唯一标识。\nfunc（Function）：\n要包装的函数，其参数会被映射为节点的输入插槽，返回值会被映射为节点的输出插槽。\nparam_types（Array，可选）：\n每个参数的类型数组（如 [\"number\", \"string\"]），用于指定输入插槽的数据类型，默认接受任意类型。\nreturn_type（String，可选）：\n函数返回值的类型（如 \"number\"），用于指定输出插槽的数据类型，默认使用通用类型。\nproperties（Object，可选）：\n节点的可配置属性（如 { precision: 2 }），用于存储节点的额外配置信息。\n\n**核心实现逻辑**\n解析函数参数并生成输入插槽代码\n```\nvar names = LiteGraph.getParameterNames(func); // 获取函数参数名（如 sum(a,b) → [\"a\", \"b\"]）\nfor (var i = 0; i < names.length; ++i) {\n    var type = 0;\n    if (param_types) {\n        // 处理参数类型：字符串类型加引号，其他类型直接使用\n        if (param_types[i] != null && typeof param_types[i] === \"string\") {\n            type = \"'\" + param_types[i] + \"'\";\n        } else if (param_types[i] != null) {\n            type = param_types[i];\n        }\n    }\n    // 生成 addInput 调用代码（如 this.addInput('a', 'number');）\n    code += \"this.addInput('\" + names[i] + \"',\" + type + \");\\n\";\n}\n```\n\n通过 getParameterNames 提取函数参数名（如 func(a, b) → [\"a\", \"b\"]）；\n根据 param_types 为每个参数指定输入插槽类型，生成对应的 addInput 调用代码；\n若 param_types 为 null，则不生成输入插槽（适用于无参函数）。\n\n2.生成输出插槽代码\n```\nif (return_type !== null) {\n    code += \"this.addOutput('out',\" + \n        (return_type != null ? (typeof return_type === \"string\" ? \"'\" + return_type + \"'\" : return_type) : 0) + \n        \");\\n\";\n}\n```\n\n根据 return_type 生成输出插槽（默认名称为 out）；\n若 return_type 为 null，则不生成输出插槽（适用于无返回值的函数）。\n\n3.添加节点属性（可选）\n```\nif (properties) {\n    code += \"this.properties = \" + JSON.stringify(properties) + \";\\n\";\n}\n```\n\n若传入 properties，则将其序列化为字符串并添加到节点构造函数中，作为节点的可配置属性。\n\n4.动态生成节点类构造函数\n```\nvar classobj = Function(code);\n\n```\n通过 Function 构造函数将上述拼接的代码字符串转换为节点类的构造函数，实现输入 / 输出插槽和属性的初始化。\n\n5.设置节点元信息\n```\nclassobj.title = name.split(\"/\").pop(); // 标题默认取名称的最后部分（如 \"sum\"）\nclassobj.desc = \"Generated from \" + func.name; // 描述为“由函数名生成”\n```\n\n6.实现 onExecute 方法\n```\nclassobj.prototype.onExecute = function onExecute() {\n    for (var i = 0; i < params.length; ++i) {\n        params[i] = this.getInputData(i); // 获取每个输入插槽的数据\n    }\n    var r = func.apply(this, params); // 调用原始函数，传入输入数据\n    this.setOutputData(0, r); // 将函数返回值设置到输出插槽\n};\n```\n自动生成执行逻辑：获取输入数据→调用原始函数→输出结果，实现函数与节点的数据流映射。\n\n\n7.注册节点类型\n```\nthis.registerNodeType(name, classobj);\nreturn classobj;\n```\n\n将生成的节点类注册到框架，并返回该类。\n\n**关键作用**\n函数与节点的快速映射：无需手动编写节点类，直接将普通函数转换为可视化节点，降低开发成本。\n自动化插槽生成：根据函数参数和返回值自动创建输入 / 输出插槽，确保节点与函数逻辑一致。\n标准化执行流程：自动实现 onExecute 方法，统一 “输入→处理→输出” 的执行逻辑。\n\n**使用场景**\n适用于包装简单的处理函数，例如将加法函数转换为节点：\n```\n// 普通加法函数\nfunction sum(a, b) {\n  return a + b;\n}\n\n// 包装为节点\nLiteGraph.wrapFunctionAsNode(\n  \"math/sum\",       // 节点名称\n  sum,              // 要包装的函数\n  [\"number\", \"number\"], // 参数类型（两个数字）\n  \"number\",         // 返回值类型（数字）\n  { label: \"Sum\" }  // 额外属性\n);\n\n```\n执行后，框架中会新增一个 math/sum 节点：\n包含两个输入插槽（a 和 b，类型为 number）；\n包含一个输出插槽（out，类型为 number）；\n执行时会调用 sum 函数，计算输入值的和并输出。\n\n**注意事项**\n适用于纯函数（输入决定输出，无副作用），复杂逻辑（如状态管理、异步操作）仍需手动编写节点类。\n函数参数名会直接作为输入插槽的显示名称，建议使用清晰的参数名（如 width、height）。\n若函数无参数或无返回值，可通过 param_types: null 或 return_type: null 禁用对应的插槽。\n"
          },
          "children": []
        },
        {
          "id": "81b7b296-6e28-49d0-8467-6caf1f6eeb03",
          "title": "clearRegisteredTypes",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/81b7b296-6e28-49d0-8467-6caf1f6eeb03",
          "content": {
            "title": "clearRegisteredTypes",
            "content": "## clearRegisteredTypes 方法注释分析\n该方法是 LiteGraph 框架中用于清除所有已注册节点类型的工具函数，作用是重置框架中与节点类型相关的注册信息，恢复到初始状态。\n### 方法功能概述\nclearRegisteredTypes 用于彻底清除框架中所有已注册的节点类型数据，包括节点类型注册表、文件扩展名关联表、节点类字典等，适用于需要重新初始化节点系统或清理所有自定义节点的场景。\n\n```\n clearRegisteredTypes: function() {\n      this.registered_node_types = {};\n      this.node_types_by_file_extension = {};\n      this.Nodes = {};\n      this.searchbox_extras = {};\n  },\n```\n\n核心实现逻辑\n方法通过将框架中存储节点类型相关信息的核心对象重置为空对象，实现清除功能：\n```\nthis.registered_node_types = {};         // 清空节点类型注册表（按类型名索引的节点类）\nthis.node_types_by_file_extension = {};  // 清空文件扩展名与节点类的关联表\nthis.Nodes = {};                         // 清空按类名索引的节点类字典\nthis.searchbox_extras = {};              // 清空搜索框的额外功能配置\n```\n### 关键作用\n1. 全面清理注册信息：一次性清除所有与节点类型相关的注册数据，确保后续注册的节点类型不受历史数据影响。\n2. 重置节点系统状态：将框架的节点管理系统恢复到初始状态，便于重新注册节点类型或加载新的节点配置。\n### 使用场景\n适用于需要完全重置节点系统的场景，例如：\n1. 动态切换不同的节点配置集（如从 “数学节点集” 切换到 “逻辑节点集”）；\n2. 应用程序退出编辑模式或重新初始化时，清理所有自定义节点；\n3. 测试不同节点组合时，确保环境干净无残留节点类型。\n\n示例用法：\n```\n// 清除所有已注册的节点类型\nLiteGraph.clearRegisteredTypes();\n\n// 之后可以重新注册所需的节点类型\nLiteGraph.registerNodeType(\"math/add\", AddNode);\nLiteGraph.registerNodeType(\"logic/and\", AndNode);\n```\n\n### 注意事项\n调用该方法后，所有已注册的节点类型将不可用，需重新注册才能使用。\n该方法仅清除注册信息，不会影响已添加到画布中的节点实例（但这些实例可能因关联的节点类被移除而出现异常）。\n若需要保留部分节点类型，不应使用此方法，而应通过 unregisterNodeType 逐个移除不需要的类型。\n"
          },
          "children": []
        },
        {
          "id": "d2482fef-e991-4dbe-8874-59002db5b452",
          "title": "addNodeMethod",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/d2482fef-e991-4dbe-8874-59002db5b452",
          "content": {
            "title": "addNodeMethod",
            "content": "## addNodeMethod 方法注释分析\n该方法是 LiteGraph 框架中用于为所有节点类型（包括已存在和未来创建的）添加共享方法的工具函数，解决了直接修改基础原型无法覆盖已有节点类型的问题。\n### 方法功能概述\naddNodeMethod 用于向所有节点类型添加一个通用方法，确保：\n1.现有已注册的节点类型能获得该方法；\n2.未来新创建的节点类型也能继承该方法；\n3.若节点类型已存在同名方法，会先保留原方法（重命名为 _原方法名）再覆盖，避免方法丢失。\n### 参数说明\n1. name（String）：\n要添加的方法名称（如 \"logData\"、\"reset\"）。\n2. func（Function）：\n要添加的方法函数体，this 指向节点实例，可访问节点的内置属性和方法（如 this.inputs、this.getInputData()）。\n\n```\n/ * *\n*将此方法添加到所有已存在的和将要创建的节点类型中\n*(可以添加到LGraphNode中。原型，但现有的节点类型不会有它)\n* @ addNodeMethod\n* @param {Function\n* /\n  addNodeMethod: function(name, func) {\n      LGraphNode.prototype[name] = func;\n      for (var i in this.registered_node_types) {\n          var type = this.registered_node_types[i];\n          if (type.prototype[name]) {\n              type.prototype[\"_\" + name] = type.prototype[name];\n          } //keep old in case of replacing\n          type.prototype[name] = func;\n      }\n  },\n```\n\n### 核心实现逻辑\n1.为基础节点原型添加方法\n```\nLGraphNode.prototype[name] = func;\n```\n\n向所有节点的基础类 LGraphNode 的原型添加方法，确保未来新创建的节点类型（继承自 LGraphNode）能自动获得该方法。\n2.为已注册的节点类型添加方法\n```\nfor (var i in this.registered_node_types) {\n    var type = this.registered_node_types[i]; // 遍历所有已注册的节点类型\n    if (type.prototype[name]) {\n        // 若节点类型已有同名方法，先保留原方法（重命名为 \"_name\"）\n        type.prototype[\"_\" + name] = type.prototype[name];\n    }\n    // 覆盖节点类型的原型方法\n    type.prototype[name] = func;\n}\n\n```\n\n1. 遍历 registered_node_types 中所有已注册的节点类型；\n2. 若节点类型的原型中已存在同名方法，将原方法重命名为 _原方法名（如原方法为 log，则保留为 _log），避免直接覆盖导致方法丢失；\n3. 为节点类型的原型添加新方法，确保现有节点类型能使用该方法。\n\n### 关键作用\n全局方法共享：一次性为所有节点类型（包括现有和未来的）添加方法，避免逐个修改节点类的繁琐。\n兼容性处理：通过保留原方法（重命名），解决方法覆盖可能导致的冲突问题。\n动态扩展能力：允许在运行时为节点系统添加新功能（如调试方法、通用工具方法），无需修改节点类的原始定义。\n\n### 使用场景\n适用于需要为所有节点添加通用功能的场景，例如添加一个日志输出方法：\n```\n// 定义一个通用日志方法\nfunction logNodeInfo() {\n  console.log(`Node ${this.type}: ${this.title}`);\n  console.log(\"Inputs:\", this.inputs.map(i => i.name));\n  console.log(\"Outputs:\", this.outputs.map(o => o.name));\n}\n\n// 为所有节点添加该方法\nLiteGraph.addNodeMethod(\"logInfo\", logNodeInfo);\n```\n\n调用后：\n1. 所有已存在的节点类型（如 math/add、logic/and）的实例都可调用 logInfo() 方法；\n2. 新创建的节点类型（如通过 registerNodeType 注册的）也会自动继承 logInfo() 方法；\n3. 若某个节点类型原本已有 logInfo 方法，会被重命名为 _logInfo 保留，新方法覆盖生效。\n\n### 注意事项\n1. 方法名称应避免与节点类已有的核心方法冲突（如 onExecute、addInput），必要时可使用前缀（如 util_xxx）。\n2. 保留的原方法（_name）可在新方法中调用（如 this._logInfo()），实现方法的扩展而非完全替换。\n3. 该方法添加的是实例方法（作用于节点实例），而非静态方法（作用于节点类）。\n"
          },
          "children": []
        },
        {
          "id": "3a11d224-8807-4ede-ba30-f96e006f05f7",
          "title": "createNode",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/3a11d224-8807-4ede-ba30-f96e006f05f7",
          "content": {
            "title": "createNode",
            "content": "## createNode 方法注释分析\n该方法是 LiteGraph 框架中用于创建节点实例的核心函数，根据指定的节点类型生成一个未附加到任何图的节点对象，为后续添加到画布做好准备。\n### 方法功能概述\ncreateNode 用于实例化一个指定类型的节点，主要功能包括：\n1.校验节点类型是否已注册；\n2.创建节点实例并初始化基础属性（如标题、位置、大小等）；\n3.应用可选配置项；\n4.触发节点创建后的回调方法。\n生成的节点暂未添加到任何图中，需通过 graph.add(node) 手动添加到画布。\n```\n/ * *\n* 创建一个指定类型的节点。该节点尚未附加到任何图。\n* @method createNode\n* @param {String}类型的节点类全名。提取物。“数学/罪”\n* @param {String} name用于区分其他节点的名称\n* @param {Object} options设置选项\n* /\n\ncreateNode: function(type, title, options) {\n  var base_class = this.registered_node_types[type];\n      if (!base_class) {\n          if (LiteGraph.debug) {\n              console.log(\n                  'GraphNode type \"' + type + '\" not registered.'\n              );\n          }\n          return null;\n      }\n\n      var prototype = base_class.prototype || base_class;\n\n      title = title || base_class.title || type;\n\n      var node = null;\n\n      if (LiteGraph.catch_exceptions) {\n          try {\n              node = new base_class(title);\n          } catch (err) {\n              console.error(err);\n              return null;\n          }\n      } else {\n          node = new base_class(title);\n      }\n\n      node.type = type;\n\n      if (!node.title && title) {\n          node.title = title;\n      }\n      if (!node.properties) {\n          node.properties = {};\n      }\n      if (!node.properties_info) {\n          node.properties_info = [];\n      }\n      if (!node.flags) {\n          node.flags = {};\n      }\n      if (!node.size) {\n          node.size = node.computeSize();\n\t//call onresize?\n      }\n      if (!node.pos) {\n          node.pos = LiteGraph.DEFAULT_POSITION.concat();\n      }\n      if (!node.mode) {\n          node.mode = LiteGraph.ALWAYS;\n      }\n\n      //extra options\n      if (options) {\n          for (var i in options) {\n              node[i] = options[i];\n          }\n      }\n\n// callback\n      if ( node.onNodeCreated ) {\n          node.onNodeCreated();\n      }\n      \n      return node;\n  },\n```\n### 参数说明\n1. type（String）：\n节点类型的全名（如 \"math/sin\"），对应注册时使用的 type 参数，用于指定要创建的节点类型。\n2. title（String，可选）：\n节点的显示名称，用于区分同类节点，默认使用节点类的 title 属性或 type 的最后部分（如 \"sin\"）。\n3. options（Object，可选）：\n额外配置项，用于设置节点的自定义属性（如 { pos: [200, 300], color: \"#f00\" }）。\n\n### 核心实现逻辑\n1.获取节点类并校验\n```\nvar base_class = this.registered_node_types[type];\nif (!base_class) {\n    if (LiteGraph.debug) {\n        console.log('GraphNode type \"' + type + '\" not registered.');\n    }\n    return null;\n}\n\n```\n从 registered_node_types 注册表中获取与 type 对应的节点类，若未找到且开启调试模式，打印警告并返回 null。\n2.处理标题默认值\n```\ntitle = title || base_class.title || type;\n\n```\n确定节点的标题：优先使用传入的 title，若未提供则使用节点类的 title 属性，否则 fallback 到 type 本身。\n3.实例化节点\n```\nvar node = null;\nif (LiteGraph.catch_exceptions) {\n    try {\n        node = new base_class(title); // 尝试实例化节点，传入标题\n    } catch (err) {\n        console.error(err);\n        return null;\n    }\n} else {\n    node = new base_class(title);\n}\n\n```\n根据 catch_exceptions 配置决定是否捕获实例化过程中的异常：若开启，则通过 try-catch 捕获错误并返回 null；否则直接实例化（可能抛出异常）。\n4.初始化基础属性\n为节点设置必要的默认属性，确保结构完整：\n```\nnode.type = type; // 记录节点类型（与注册时一致）\n\n// 标题默认值\nif (!node.title && title) {\n    node.title = title;\n}\n\n// 初始化属性存储（配置信息）\nif (!node.properties) {\n    node.properties = {};\n}\nif (!node.properties_info) {\n    node.properties_info = []; // 属性的元信息（如类型、描述）\n}\n\n// 初始化标志位（如是否折叠、锁定）\nif (!node.flags) {\n    node.flags = {};\n}\n\n// 初始化大小（默认通过 computeSize 计算）\nif (!node.size) {\n    node.size = node.computeSize();\n}\n\n// 初始化位置（默认使用 DEFAULT_POSITION）\nif (!node.pos) {\n    node.pos = LiteGraph.DEFAULT_POSITION.concat(); // 复制默认位置数组，避免引用共享\n}\n\n// 初始化模式（默认 ALWAYS 模式）\nif (!node.mode) {\n    node.mode = LiteGraph.ALWAYS;\n}\n```\n5.应用可选配置\n```\nif (options) {\n    for (var i in options) {\n        node[i] = options[i]; // 将配置项中的属性直接赋值给节点\n    }\n}\n\n```\n若传入 options，则遍历配置项并赋值给节点，覆盖默认属性（如自定义位置、颜色等）。\n6.触发创建后回调\n```\nif (node.onNodeCreated) {\n    node.onNodeCreated(); // 调用节点类中定义的创建后回调\n}\n\n```\n若节点类定义了 onNodeCreated 方法，在节点实例化完成后调用，用于执行额外的初始化逻辑。\n7.返回节点实例\n```\nreturn node;\n\n```\n返回创建好的节点实例，此时节点尚未添加到任何图中。\n\n### 关键作用\n1. 标准化节点创建流程：确保所有节点实例都包含必要的基础属性（如 type、pos、size），避免结构缺失。\n2. 错误处理：通过异常捕获机制，在节点实例化失败时提供清晰的错误信息，增强框架稳定性。\n3. 灵活性扩展：支持通过 options 自定义节点属性，满足个性化需求。\n\n### 使用场景\n创建节点实例并添加到图中，例如：\n```\n// 创建一个 \"math/add\" 节点\nconst addNode = LiteGraph.createNode(\n  \"math/add\",       // 节点类型\n  \"My Add Node\",    // 自定义标题\n  { pos: [150, 200] } // 初始位置\n);\n\n// 将节点添加到图中（假设 graph 是一个 LGraph 实例）\nif (addNode) {\n  graph.add(addNode);\n}\n\n```\n执行后，addNode 会成为一个可在画布中显示和操作的节点实例。\n\n### 注意事项\n1. 节点创建后需手动添加到图中（通过 graph.add(node)），否则不会在画布中显示。\n2. 若节点类的构造函数需要额外参数，需在 base_class 的定义中处理，createNode 仅传入 title 作为参数。\n3. options 中的属性会直接覆盖节点的默认属性，使用时需确保属性名合法（如 pos、size 等是节点的标准属性）。"
          },
          "children": []
        },
        {
          "id": "0a952e4e-002f-4719-bfa6-6f3fe9a086a5",
          "title": "getNodeType",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/0a952e4e-002f-4719-bfa6-6f3fe9a086a5",
          "content": {
            "title": "getNodeType",
            "content": "## getNodeType 方法注释分析\n该方法是 LiteGraph 框架中用于获取已注册节点类型的工具函数，通过节点类型的唯一标识，返回对应的节点类，方便后续对节点类进行操作（如实例化、扩展等）。\n### 方法功能概述\ngetNodeType 用于从框架的节点类型注册表中查询并返回指定类型的节点类。通过该方法，开发者可以获取已注册节点的类定义，用于动态创建节点实例、检查节点类属性或进行扩展等操作。\n### 参数说明\n1. type（String）：\n节点类型的全名（格式为 分类/节点名，如 \"math/sin\"），对应节点注册时使用的 type 参数，作为查询的唯一标识。\n### 返回值说明\n2. Class：返回与 type 对应的节点类（构造函数）；若该类型未注册，则返回 undefined。\n\n```\n/ * *\n* 返回给定名称的注册节点类型\n* @方法getNodeType\n* @param {String}类型的节点类全名。p.e.“math/sin”\n* @返回{Class}节点类\n* /\ngetNodeType: function(type) {\n    return this.registered_node_types[type];\n},\n```\n\n### 核心实现逻辑\n方法通过直接访问框架的节点类型注册表 registered_node_types，根据 type 参数获取对应的节点类：\n```\nreturn this.registered_node_types[type];\n```\n\nregistered_node_types 是一个以节点类型名为键、节点类为值的字典，因此该方法本质上是一个简单的键值对查询操作。\n\n### 关键作用\n1. **查询节点类**：提供了一种便捷的方式获取已注册节点的类定义，无需手动维护节点类的引用。\n2. **支持动态操作**：结合返回的节点类，可实现动态创建节点（如 new getNodeType(\"math/sin\")()）、检查类属性（如 getNodeType(\"math/sin\").title）等功能。\n\n### 使用场景\n适用于需要根据节点类型名动态获取节点类的场景，例如：\n1. 动态创建节点：\n```\n// 获取 \"math/sin\" 节点类\nconst SinNode = LiteGraph.getNodeType(\"math/sin\");\nif (SinNode) {\n    // 实例化节点\n    const sinNode = new SinNode(\"Sine Calculator\");\n    graph.add(sinNode); // 添加到图中\n}\n```\n\n2. 检查节点类信息：\n```\nconst AddNode = LiteGraph.getNodeType(\"math/add\");\nif (AddNode) {\n    console.log(\"节点标题：\", AddNode.title);\n    console.log(\"节点描述：\", AddNode.desc);\n}\n```\n\n3. 扩展节点类：\n```\nconst BaseNode = LiteGraph.getNodeType(\"base/value\");\nif (BaseNode) {\n    // 扩展节点类的原型方法\n    BaseNode.prototype.logValue = function() {\n        console.log(\"当前值：\", this.properties.value);\n    };\n}\n```\n\n### 注意事项\n1. 若查询的节点类型未注册（如拼写错误或未调用 registerNodeType），该方法会返回 undefined，使用前需进行有效性检查。\n2. 返回的是节点类（构造函数），而非节点实例，需通过 new 关键字才能创建实例。\n3. 该方法仅返回已注册的节点类，未注册的类型无法通过此方法获取。"
          },
          "children": []
        },
        {
          "id": "2723b176-1124-44f7-a4f2-218d7e448222",
          "title": "getNodeTypesInCategory",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/2723b176-1124-44f7-a4f2-218d7e448222",
          "content": {
            "title": "getNodeTypesInCategory",
            "content": "## getNodeTypesInCategory 方法注释分析\n该方法是 LiteGraph 框架中用于按分类筛选节点类型的工具函数，作用是从已注册的节点类型中，筛选出属于指定分类的节点类列表，方便按类别展示或处理节点类型。\n### 方法功能概述\ngetNodeTypesInCategory 用于查询并返回属于指定分类的所有节点类型，支持通过分类名称精确筛选，还可配合过滤器进一步限制结果。筛选后的列表可根据配置自动排序，常用于节点选择菜单、分类展示等场景。\n### 参数说明\n1. category（String）：\n分类名称（如 \"math\"、\"logic\"），用于筛选属于该分类的节点类型；若传入空字符串 \"\"，则筛选未指定分类（category 为 null）的节点类型。\n2. filter（可选参数）：\n过滤器条件，用于进一步筛选节点类型（仅保留 type.filter 与 filter 匹配的节点类）。\n### 返回值说明\nArray：返回符合条件的节点类数组，每个元素是一个节点构造函数；若没有匹配的节点类型，返回空数组。\n\n```\n/ * *\n* 返回与一个类别匹配的节点类型列表\n* @方法getNodeType\n* @param {String} category类别名称\n* @返回{Array}包含所有节点类的数组\n* /\n  getNodeTypesInCategory: function(category, filter) {\n      var r = [];\n      for (var i in this.registered_node_types) {\n          var type = this.registered_node_types[i];\n          if (type.filter != filter) {\n              continue;\n          }\n\n          if (category == \"\") {\n              if (type.category == null) {\n                  r.push(type);\n              }\n          } else if (type.category == category) {\n              r.push(type);\n          }\n      }\n\n      if (this.auto_sort_node_types) {\n          r.sort(function(a,b){return a.title.localeCompare(b.title)});\n      }\n\n      return r;\n  },\n```\n### 核心实现逻辑\n1.初始化结果数组\n```\nvar r = [];\n\n```\n创建空数组 r 用于存储筛选结果。\n2.遍历所有注册的节点类型\n```\nfor (var i in this.registered_node_types) {\n    var type = this.registered_node_types[i]; // 获取当前节点类\n\n```\n遍历 registered_node_types 中所有已注册的节点类型（i 为节点类型名，type 为对应的节点类）。\n3.应用过滤器（可选）\n```\nif (type.filter != filter) {\n    continue; // 若节点类的 filter 与参数不匹配，跳过当前节点\n}\n\n```\n若传入了 filter 参数，则仅保留 type.filter 与 filter 一致的节点类，否则跳过此检查。\n4.按分类筛选\n```\nif (category == \"\") {\n    // 若分类为空字符串，筛选未设置分类（category 为 null）的节点类\n    if (type.category == null) {\n        r.push(type);\n    }\n} else {\n    // 否则筛选分类完全匹配的节点类\n    if (type.category == category) {\n        r.push(type);\n    }\n}\n\n```\n当 category 为空字符串时，收集 type.category 为 null 的节点类（未归类的节点）；\n当 category 为具体分类名时，收集 type.category 与之完全匹配的节点类。\n5.排序结果（可选）\n```\nif (this.auto_sort_node_types) {\n    r.sort(function(a, b) { return a.title.localeCompare(b.title); });\n}\n\n```\n若 auto_sort_node_types 为 true，则按节点类的 title 属性（标题）进行字母排序，确保结果列表有序。\n6.返回筛选结果\n```\nreturn r;\n\n```\n返回筛选并排序后的节点类数组。\n\n### 关键作用\n1.分类筛选：快速从所有注册节点中提取指定分类的节点类型，便于按类别展示（如节点菜单中的分类列表）。\n2.灵活过滤：支持通过 filter 参数进一步限制结果，满足更精细的筛选需求（如按节点功能、类型等）。\n3.自动排序：可选的排序功能确保结果列表有序，提升用户体验（如菜单中的节点按名称排列）。\n\n### 使用场景\n适用于需要按分类处理节点类型的场景，例如：\n1.获取 “math” 分类下的所有节点：\n```\nconst mathNodes = LiteGraph.getNodeTypesInCategory(\"math\");\nconsole.log(\"数学节点列表：\", mathNodes.map(node => node.title));\n\n```\n2.获取未分类的节点：\n```\nconst uncategorizedNodes = LiteGraph.getNodeTypesInCategory(\"\");\n\n```\n3.结合过滤器筛选特定节点：\n```\n// 假设存在 filter 为 \"advanced\" 的节点类\nconst advancedMathNodes = LiteGraph.getNodeTypesInCategory(\"math\", \"advanced\");\n\n```\n4.在 UI 中展示分类节点列表：\n```\n// 为菜单添加“逻辑”分类下的节点\nconst logicNodes = LiteGraph.getNodeTypesInCategory(\"logic\");\nlogicNodes.forEach(nodeClass => {\n    addToMenu(nodeClass.title, () => createNode(nodeClass.type));\n});\n```\n\n### 注意事项\n1.分类匹配是精确匹配（区分大小写），例如 \"Math\" 与 \"math\" 会被视为不同分类。\n2.若节点类未设置 category 属性（即 type.category 为 undefined），不会被空字符串 category 筛选（仅匹配 type.category == null 的节点）。\n3.排序依赖节点类的 title 属性，若部分节点未设置 title，可能导致排序异常（建议所有节点类都定义 title）。\n"
          },
          "children": []
        },
        {
          "id": "984763ca-59d5-4f28-a2ba-c33af798dc54",
          "title": "getNodeTypesCategories",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/984763ca-59d5-4f28-a2ba-c33af798dc54",
          "content": {
            "title": "getNodeTypesCategories",
            "content": "## getNodeTypesCategories 方法注释分析\n该方法是 LiteGraph 框架中用于获取所有节点类型分类的工具函数，作用是从已注册的节点类型中提取所有不重复的分类名称，方便在 UI 中展示分类列表或进行分类相关的操作。\n### 方法功能概述\ngetNodeTypesCategories 用于收集并返回框架中所有已注册节点类型的分类名称，支持通过过滤器筛选特定类别的分类。返回的分类列表可根据配置自动排序，常用于节点选择菜单的分类导航、分类统计等场景。\n### 参数说明\n1. filter（可选参数）：\n过滤器条件，仅包含 ctor.filter（节点类的 filter 属性）与该参数匹配的节点类型所属的分类。若不传入，则返回所有符合条件的分类。\n### 返回值说明\n1. Array：返回所有不重复的分类名称数组，包含空字符串（代表未分类）；若没有符合条件的分类，返回空数组。\n\n```\n/ **\n* 返回一个包含所有节点类型类别的列表\n* @方法getNodeTypesCategories\n* @param {String}只过滤带有ctor的节点。过滤器等于可以显示\n* @返回{Array}包含所有类别名称的数组\n* /\n   getNodeTypesCategories: function( filter ) {\n     var categories = { \"\": 1 };\n      for (var i in this.registered_node_types) {\n\tvar type = this.registered_node_types[i];\n          if ( type.category && !type.skip_list )\n          {\n\t\tif(type.filter != filter)\n\t\t\tcontinue;\n              categories[type.category] = 1;\n          }\n      }\n      var result = [];\n      for (var i in categories) {\n          result.push(i);\n      }\n      return this.auto_sort_node_types ? result.sort() : result;\n  },\n```\n\n### 核心实现逻辑\n1.初始化分类集合\n```\nvar categories = { \"\": 1 };\n\n```\n创建一个对象 categories 用于存储分类名称（键为分类名，值为 1 用于去重），初始包含空字符串（代表未分类）。\n2.遍历所有注册的节点类型\n```\nfor (var i in this.registered_node_types) {\n    var type = this.registered_node_types[i]; // 获取当前节点类\n\n```\n遍历 registered_node_types 中所有已注册的节点类型。\n3.筛选符合条件的节点类型\n```\nif (type.category && !type.skip_list) {\n    // 检查过滤器条件\n    if (type.filter != filter)\n        continue;\n    // 将分类添加到集合中（自动去重）\n    categories[type.category] = 1;\n}\n\n```\n- 仅处理包含 category 属性且未设置 skip_list（不跳过列表）的节点类；\n- 若传入 filter 参数，仅保留 type.filter 与之匹配的节点类；\n- 将节点类的 category 加入 categories 对象（利用对象键的唯一性实现去重）。\n4.转换为数组并排序\n```\nvar result = [];\nfor (var i in categories) {\n    result.push(i); // 将分类名从对象键转换为数组元素\n}\n// 根据配置决定是否排序\nreturn this.auto_sort_node_types ? result.sort() : result;\n\n```\n将 categories 对象的键（分类名）提取到数组 result 中；\n若 auto_sort_node_types 为 true，对分类名进行字母排序，否则返回原始顺序。\n\n### 关键作用\n- 分类去重与收集：自动提取所有节点类型的分类名称并去重，确保每个分类仅出现一次。\n- 支持过滤：通过 filter 参数可按节点类的 filter 属性筛选分类，满足特定场景需求（如只显示 “高级” 分类下的子分类）。\n- 排序控制：根据框架配置决定是否对分类进行排序，保证 UI 展示的一致性。\n\n### 使用场景\n适用于需要展示或处理节点分类的场景，例如：\n1.获取所有分类列表：\n```\nconst allCategories = LiteGraph.getNodeTypesCategories();\nconsole.log(\"所有分类：\", allCategories); // 例如 [\"\", \"math\", \"logic\", \"event\"]\n\n```\n2.获取特定过滤器下的分类：\n```\n// 假设存在 filter 为 \"basic\" 的节点类\nconst basicCategories = LiteGraph.getNodeTypesCategories(\"basic\");\n\n```\n3.在 UI 中构建分类菜单：\n```\n// 生成分类选择菜单\nconst categories = LiteGraph.getNodeTypesCategories();\ncategories.forEach(category => {\n    const menuItem = createMenuItem(\n        category || \"未分类\", // 空字符串显示为“未分类”\n        () => showNodesInCategory(category)\n    );\n    addToMenuBar(menuItem);\n});\n```\n\n### 注意事项\n* 空字符串 \"\" 代表未分类的节点（type.category 为 null 或未设置的节点），在 UI 中通常显示为 “未分类” 或类似名称。\n* type.skip_list 为 true 的节点类会被忽略，其所属分类不会被计入结果。\n* 排序是字母序排序（区分大小写），若需要自定义排序规则，需在方法返回后手动处理。"
          },
          "children": []
        },
        {
          "id": "7868c663-9a61-48da-adea-dad32db45e1b",
          "title": "reloadNodes",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/7868c663-9a61-48da-adea-dad32db45e1b",
          "content": {
            "title": "reloadNodes",
            "content": "## reloadNodes 方法注释分析\n该方法是 LiteGraph 框架中用于调试的工具函数，作用是重新加载匹配指定路径规则的 JavaScript 脚本文件，主要用于开发阶段快速更新节点定义，无需手动刷新页面即可应用代码变更。\n### 方法功能概述\nreloadNodes 通过重新加载符合路径规则的脚本文件，实现节点代码的动态更新。其核心逻辑是：查找页面中已加载的、路径匹配 folder_wildcard 的脚本，通过创建新的 \\<script> 标签重新加载这些脚本，并移除旧的脚本标签，从而使新的节点定义生效。\n### 参数说明\n- folder_wildcard（String）：\n脚本文件路径的匹配规则（如 \"nodes/*.js\"），用于筛选需要重新加载的脚本。方法会将其与当前页面 URL 拼接，形成完整的路径前缀进行匹配。\n```\n  //debug purposes: reloads all the js scripts that matches a wildcard\n  reloadNodes: function(folder_wildcard) {\n      var tmp = document.getElementsByTagName(\"script\");\n      //weird, this array changes by its own, so we use a copy\n      var script_files = [];\n      for (var i=0; i < tmp.length; i++) {\n          script_files.push(tmp[i]);\n      }\n\n      var docHeadObj = document.getElementsByTagName(\"head\")[0];\n      folder_wildcard = document.location.href + folder_wildcard;\n\n      for (var i=0; i < script_files.length; i++) {\n          var src = script_files[i].src;\n          if (\n              !src ||\n              src.substr(0, folder_wildcard.length) != folder_wildcard\n          ) {\n              continue;\n          }\n\n          try {\n              if (LiteGraph.debug) {\n                  console.log(\"Reloading: \" + src);\n              }\n              var dynamicScript = document.createElement(\"script\");\n              dynamicScript.type = \"text/javascript\";\n              dynamicScript.src = src;\n              docHeadObj.appendChild(dynamicScript);\n              docHeadObj.removeChild(script_files[i]);\n          } catch (err) {\n              if (LiteGraph.throw_errors) {\n                  throw err;\n              }\n              if (LiteGraph.debug) {\n                  console.log(\"Error while reloading \" + src);\n              }\n          }\n      }\n\n      if (LiteGraph.debug) {\n          console.log(\"Nodes reloaded\");\n      }\n  },\n\n```\n\n### 核心实现逻辑\n\n1.收集页面中已加载的脚本\n```\nvar tmp = document.getElementsByTagName(\"script\");\nvar script_files = [];\nfor (var i = 0; i < tmp.length; i++) {\n    script_files.push(tmp[i]); // 复制脚本元素到数组，避免遍历中DOM变化影响结果\n}\n\n```\n通过 getElementsByTagName(\"script\") 获取页面中所有 \\<script> 元素，并复制到 script_files 数组（防止遍历过程中 DOM 动态变化导致的异常）。\n  2.构建完整的路径前缀\n```\nfolder_wildcard = document.location.href + folder_wildcard;\n\n```\n将传入的路径规则与当前页面 URL 拼接，形成用于匹配脚本路径的完整前缀（如页面 URL 为 <http://example.com/>，则 folder_wildcard 为 \"nodes/*.js\" 时，完整前缀为 <http://example.com/nodes/*.js>）。\n  3.筛选并重新加载匹配的脚本\n```\nfor (var i = 0; i < script_files.length; i++) {\n    var src = script_files[i].src; // 脚本的 src 属性（完整路径）\n    // 跳过路径不匹配的脚本\n    if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard) {\n        continue;\n    }\n\n    try {\n        if (LiteGraph.debug) {\n            console.log(\"Reloading: \" + src); // 调试模式下打印重新加载的脚本路径\n        }\n        // 创建新的 script 标签\n        var dynamicScript = document.createElement(\"script\");\n        dynamicScript.type = \"text/javascript\";\n        dynamicScript.src = src; // 设置与原脚本相同的 src\n        docHeadObj.appendChild(dynamicScript); // 添加到 head 中，触发重新加载\n        docHeadObj.removeChild(script_files[i]); // 移除旧的 script 标签\n    } catch (err) {\n        // 错误处理\n        if (LiteGraph.throw_errors) throw err;\n        if (LiteGraph.debug) console.log(\"Error while reloading \" + src);\n    }\n}\n\n\n```\n- 遍历所有脚本，通过 substr 检查脚本路径是否以 folder_wildcard 为前缀（即匹配路径规则）；\n- 对匹配的脚本，创建新的 \\<script> 标签并设置相同的 src，添加到 \\<head> 中触发重新加载；\n- 移除旧的脚本标签，避免重复执行；\n- 若开启调试模式，打印重新加载的脚本路径及可能的错误信息。\n4.输出重新加载完成信息\n```\nif (LiteGraph.debug) {\n    console.log(\"Nodes reloaded\");\n}\n\n```\n调试模式下，在所有匹配脚本处理完成后打印提示信息。\n\n### 关键作用\n- 动态更新节点代码：在开发阶段无需刷新页面，即可重新加载节点定义脚本，快速验证代码变更，提升开发效率。\n- 精准匹配脚本：通过路径前缀匹配，仅重新加载指定目录下的脚本（如节点定义目录），避免影响其他脚本。\n- 调试友好：提供详细的日志输出，便于追踪重新加载过程及排查错误。\n\n### 使用场景\n适用于开发环境中快速更新节点代码，例如：\n```\n// 重新加载 \"nodes/\" 目录下的所有脚本\nLiteGraph.reloadNodes(\"nodes/\");\n```\n执行后，页面中所有路径以当前 URL + \"nodes/\" 开头的脚本（如 <http://example.com/nodes/math.js>）会被重新加载，新的节点定义将生效。\n\n### 注意事项\n- 仅适用于开发调试场景，生产环境中不建议使用（可能导致重复执行脚本或状态异常）。\n- 重新加载脚本可能导致全局变量、事件监听等重复定义，需确保脚本支持多次加载（如使用模块化封装）。\n- 路径匹配是前缀匹配，需确保 folder_wildcard 能准确区分目标脚本（如避免使用过于宽泛的规则）。\n- 旧脚本标签被移除后，其定义的变量 / 函数不会自动清除，若新脚本中未覆盖，可能残留旧代码逻辑。"
          },
          "children": []
        },
        {
          "id": "1a9cd442-8a47-4fa1-bb42-8c173eab2e94",
          "title": "cloneObject",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/1a9cd442-8a47-4fa1-bb42-8c173eab2e94",
          "content": {
            "title": "cloneObject",
            "content": "## cloneObject 方法注释分析\n该方法是 LiteGraph 框架中用于克隆对象的工具函数，通过 JSON 序列化与反序列化实现对象的深拷贝，并支持将克隆结果合并到目标对象中，适用于需要复制对象且保持原始对象独立性的场景。\n\n### 方法功能概述\ncloneObject 用于创建一个对象的深拷贝（深层克隆），确保克隆后的对象与原对象完全独立（修改克隆不会克隆对象不会影响原对象）。同时支持将克隆结果合并到指定的目标对象中，覆盖或补充目标对象的属性。\n#### 参数说明\n* obj（Object）：\n  要克隆的源对象，可为任意可序列化的 JavaScript 对象（若为 null 或 undefined，直接返回 null）。\n* target（Object，可选）：\n  目标对象，若指定则将克隆结果合并到该对象中（覆盖同名属性，新增源对象有而目标对象没有的属性）；若不指定，直接返回克隆后的新对象。\n\n#### 返回值说明\n* 若未指定 target，返回克隆后的新对象；\n* 若指定 target，返回合并了克隆结果的 target 对象本身。\n\n```\ncloneObject: function(obj, target) {\n    if (obj == null) {\n        return null;\n    }\n    var r = JSON.parse(JSON.stringify(obj));\n    if (!target) {\n        return r;\n    }\n\n    for (var i in r) {\n        target[i] = r[i];\n    }\n    return target;\n},\n```\n#### 核心实现逻辑\n1. 处理空值情况\n```\nif (obj == null) {\n    return null;\n}\n\n```\n若源对象为 null 或 undefined，直接返回 null，避免后续处理出错。\n\n2. 通过 JSON 序列化克隆对象\n```\nvar r = JSON.parse(JSON.stringify(obj));\n\n```\n- 先通过 JSON.stringify(obj(obj) 将源对象序列化为 JSON 字符串；\n- 再通过 JSON.parse(r) 将字符串反序列化为新对象，实现深拷贝（嵌套对象也会被完整克隆）。\n这种方式的优点是简单高效，缺点是无法克隆函数、正则表达式、日期对象等特殊类型（会被转换为字符串或丢失信息）。\n\n3. 处理目标对象（可选）\n```\nif (!target) {\n    return r; // 未指定目标对象，直接返回克隆结果\n}\n\n// 合并克隆结果到目标对象\nfor (var i in r) {\n    target[i] = r[i];\n}\nreturn target;\n\n```\n\n- 若未传入 target，直接返回克隆后的新对象 r；\n- 若传入 target，遍历克隆对象 r 的所有属性，将其赋值给 target（覆盖现有属性，新增不存在的属性），最终返回 target。\n\n#### 关键作用\n- 深拷贝对象：通过 JSON 序列化实现对象的深拷贝，确保克隆对象与源对象完全独立，适用于需要复制配置、状态等数据的场景。\n- 灵活合并：支持将克隆结果合并到目标对象，便于在保留目标对象原有结构的基础上更新数据。\n- 简化实现：利用 JSON 方法快速实现深拷贝，避免手动递归克隆的复杂性。\n\n#### 使用场景\n适用于需要复制对象且避免引用关联的场景，例如：\n\n1. 简单克隆对象：\n```\nconst original = { a: 1, b: { c: 2 } };\nconst clone = LiteGraph.cloneObject(original);\nclone.b.c = 3; // 修改克隆对象的嵌套属性\nconsole.log(original.b.c); // 输出 2（原对象不受影响）\n\n```\n\n2. 合并到目标对象：\n```\nconst target = { a: 0, d: 4 };\nconst original = { a: 1, b: { c: 2 } };\nLiteGraph.cloneObject(original, target);\nconsole.log(target); // 输出 { a: 1, d: 4, b: { c: 2 } }（覆盖a，新增b）\n\n```\n\n3. 复制节点配置：\n```\n// 克隆节点的属性配置，用于创建相似节点\nconst nodeConfig = node.properties;\nconst newConfig = LiteGraph.cloneObject(nodeConfig);\nconst newNode = LiteGraph.createNode(\"math/add\", \"Clone\", { properties: newConfig });\n\n```\n\n#### 注意事项\n- 不支持特殊类型：无法正确克隆函数、正则表达式、Date 对象、Map/Set 等特殊类型（Date 会被转为字符串，函数会被忽略）。\n- 循环引用问题：若源对象存在循环引用（如 obj.self = obj），JSON.stringify 会抛出错误，导致克隆失败。\n- 性能考量：对于大型复杂对象，JSON 序列化 / 反序列化可能影响性能，需谨慎使用。\n若需克隆包含特殊类型或循环引用的对象，需使用更复杂的递归克隆方法，而本方法适用于克隆简单的 JSON 可序列化对象。"
          },
          "children": []
        },
        {
          "id": "4797b7ee-5560-43c0-adca-43d8fa369655",
          "title": "uuidv4",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/4797b7ee-5560-43c0-adca-43d8fa369655",
          "content": {
            "title": "uuidv4",
            "content": "## uuidv4 方法注释分析\n该方法用于生成符合 UUID v4 标准的唯一标识符（Universally Unique Identifier），通过特定的算法生成一个随机的 128 位数值，通常以 36 个字符的字符串形式表示（包含连字符）。UUID v4 主要基于随机数生成，适用于需要唯一标识的场景（如节点 ID、链接 ID 等）。\n\n#### 方法功能概述\nuuidv4 生成一个符合 UUID v4 格式的字符串，结构为 8-4-4-4-12 共五段十六进制字符（如 f47ac10b-58cc-4372-a567-0e02b2c3d479）。其中特定位置的字符固定用于标识 UUID 版本和变体，其余字符为随机生成，确保全球唯一性。\n```\n  uuidv4: function() {\n        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,a=>(a^Math.random()*16>>a/4).toString(16));\n  },\n```\n\n#### 核心实现逻辑\n方法通过字符串模板和正则替换实现 UUID 生成，核心代码：\n```\nreturn ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,a=>(a^Math.random()*16>>a/4).toString(16));\n```\n1. 字符串模板\n[1e7]+-1e3+-4e3+-8e3+-1e11 生成一个初始模板字符串，格式为 10000000-1000-4000-8000-100000000000。该模板的作用是：\n- 固定 UUID 的分段结构（8-4-4-4-12）；\n- 固定版本号和变体标识位：\n  - 第三段的第一个字符固定为 4（标识为 UUID v4）；\n  - 第四段的第一个字符固定为 8、9、a 或 b（标识 RFC 4122 中定义的变体）。\n2. 正则替换生成随机字符\n- 正则 /[018]/g 匹配模板中所有的 0、1、8 字符（这些位置需要替换为随机十六进制数）；\n- 替换函数 a => (a ^ Math.random() * 16 >> a / 4).toString(16) 生成随机十六进制字符：\n  - Math.random() * 16 生成 0-16 之间的随机数；\n  - >> a / 4 进行位移运算（根据原字符 a 调整，确保结果在 0-15 范围内）；\n  - a ^ ... 进行异或运算，进一步随机化结果；\n  - .toString(16) 将结果转换为十六进制字符串（0-9, a-f);\n3. 最终格式\n替换完成后，得到符合 UUID v4 标准的字符串，例如 3b9a7c8d-1f2e-4567-890a-bcdef1234567。\n\n#### 关键作用\n- 生成唯一标识：通过随机数生成算法，确保在实际应用中生成的 UUID 具有极高的唯一性，可用于标识节点、链接、会话等需要唯一区分的对象。\n- 符合标准格式：生成的字符串严格遵循 UUID v4 规范，便于与其他系统兼容（如数据库、API 等）。\n- 轻量高效：通过简洁的字符串操作和随机数生成实现，无需复杂的计算，性能开销低。\n\n#### 使用场景\n适用于需要唯一标识的场景，例如：\n1. 为节点生成唯一 ID：\n```\nconst nodeId = LiteGraph.uuidv4();\nconsole.log(\"节点唯一ID：\", nodeId); // 如 \"a1b2c3d4-5678-4fgh-ijkl-mnopqrstuvw\"\n\n```\n2. 标识节点间的链接：\n```\nfunction createLink(sourceNode, targetNode) {\n    return {\n        id: LiteGraph.uuidv4(),\n        from: sourceNode.id,\n        to: targetNode.id\n    };\n}\n\n```\n3. 跟踪动态生成的对象：\n```\nconst tempObject = {\n    id: LiteGraph.uuidv4(),\n    data: \"临时数据\"\n};\n// 后续可通过 id 唯一识别该对象\n\n```\n\n#### 注意事项\n- 随机性与唯一性：该方法依赖 Math.random() 生成随机数，虽然在大多数场景下足够唯一，但在极高并发或安全敏感场景（如加密标识）中，建议使用更安全的随机数生成器（如 crypto.getRandomValues）。\n- 大小写：生成的十六进制字符为小写（a-f），若需要大写可通过 .toUpperCase() 转换。\n- 长度固定：UUID v4 固定为 36 个字符（包含 4 个连字符），不可修改长度。\n总体而言，该方法是一个轻量、实用的 UUID v4 生成实现，适用于 LiteGraph 框架中对节点、链接等对象的唯一标识需求。"
          },
          "children": []
        },
        {
          "id": "f8ae8d75-600b-44c4-b618-83c3b09997ba",
          "title": "isValidConnection",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/f8ae8d75-600b-44c4-b618-83c3b09997ba",
          "content": {
            "title": "isValidConnection",
            "content": "## isValidConnection 方法注释分析\n该方法是 LiteGraph 框架中用于判断两个插槽（输入 / 输出插槽）类型是否否兼容的核心函数，决定了两个节点的插槽之间是否否能否建立连接，确保数据在节点间正确流转。\n#### 方法功能概述\nisValidConnection 用于检查两个插槽类型（type_a 和 type_b）是否可以建立连接，支持通配符、多类型匹配、事件与动作的特殊匹配等规则，是节点间连接合法性的判断依据。\n#### 参数说明\n- type_a（String）：\n第一个插槽的类型（通常是输出插槽类型）。\n- type_b（String）：\n第二个插槽的类型（通常是输入插槽类型）。\n返回值：Boolean（true 表示类型兼容，可建立连接；false 表示不兼容）。\n```\nisValidConnection: function(type_a, type_b) {\n  / * *\n  * 如果两个槽的类型兼容（考虑通配符等）则返回\n  * @方法isValidConnection\n  * @param {String} type_a\n  * @param {String} type_b\n  * @返回{布尔}true如果它们可以连接\n  * /\n  if (type_a==\"\" || type_a===\"*\") type_a = 0;\n  if (type_b==\"\" || type_b===\"*\") type_b = 0;\n      if (\n          !type_a //generic output\n          || !type_b // generic input\n          || type_a == type_b //same type (is valid for triggers)\n          || (type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION)\n      ) {\n          return true;\n      }\n\n      // Enforce string type to handle toLowerCase call (-1 number not ok)\n      type_a = String(type_a);\n      type_b = String(type_b);\n      type_a = type_a.toLowerCase();\n      type_b = type_b.toLowerCase();\n\n      // For nodes supporting multiple connection types\n      if (type_a.indexOf(\",\") == -1 && type_b.indexOf(\",\") == -1) {\n          return type_a == type_b;\n      }\n\n      // Check all permutations to see if one is valid\n      var supported_types_a = type_a.split(\",\");\n      var supported_types_b = type_b.split(\",\");\n      for (var i = 0; i < supported_types_a.length; ++i) {\n          for (var j = 0; j < supported_types_b.length; ++j) {\n              if(this.isValidConnection(supported_types_a[i],supported_types_b[j])){\n\t\t//if (supported_types_a[i] == supported_types_b[j]) {\n                  return true;\n              }\n          }\n      }\n\n      return false;\n  },\n```\n\n### 核心实现逻辑\n1. 处理通配符与空类型\n```\nif (type_a === \"\" || type_a === \"*\") type_a = 0;\nif (type_b === \"\" || type_b === \"*\") type_b = 0;\n\n```\n将空字符串 \"\" 或通配符 \"*\" 统一转换为 0，代表 “通用类型”（可匹配任何类型）。\n\n2. 基础兼容规则判断\n```\nif (\n    !type_a // 输出为通用类型（可连接任何输入）\n    || !type_b // 输入为通用类型（可接受任何任何输出）\n    || type_a === type_b // 类型完全相同（包括事件触发类）\n    || (type_a === LiteGraph.EVENT && type_b === LiteGraph.ACTION) // 事件与动作特殊匹配\n) {\n    return true;\n}\n\n```\n满足以下 4 种基础兼容情况直接直接返回 true：\n- 输出为通用类型（如通配符）；\n- 输入为通用类型（如通配符）；\n- 两者类型完全一致；\n- 输出是 EVENT（事件）且输入是 ACTION（动作）（框架特殊规则）。\n\n3. 统一类型格式并大小写\n```\ntype_a = String(type_a).toLowerCase();\ntype_b = String(type_b).toLowerCase();\n\n```\n将类型转换为字符串并转为小写，避免因大小写或格式差异导致的匹配失败（如 \"Number\" 与 \"Number\" 视为相同）。\n\n4. 处理多类型匹配（逗号分隔）\n若类型包含逗号（如 \"number,string\" 表示支持多种类型），则拆分后检查是否存在任一匹配：\n```\n// 若均为单类型，直接比较\nif (type_a.indexOf(\",\") === -1 && type_b.indexOf(\",\") === -1) {\n    return type_a === type_b;\n}\n\n// 拆分多类型并递归检查所有组合\nvar supported_types_a = type_a.split(\",\");\nvar supported_types_b = type_b.split(\",\");\nfor (var i = 0; i < supported_types_a.length; ++i) {\n    for (var j = 0; j < supported_types_b.length; ++j) {\n        if (this.isValidConnection(supported_types_a[i], supported_types_b[j])) {\n            return true;\n        }\n    }\n}\n\n\n```\n- 例如 type_a 为 \"number,string\" 且 type_b 为 \"string,boolean\" 时，拆分后检查到 string 匹配，返回 true；\n- 通过递归调用自身，支持多层级的多类型匹配。\n\n5. 默认返回不兼容\n```\nreturn false;\n\n```\n若以上规则均不满足，返回 false（类型不兼容）。\n#### 关键作用\n- 连接合法性校验：确保只有类型兼容的插槽才能建立连接，避免数据类型不匹配导致的错误（如将字符串输入到需要数字的节点）。\n- 灵活的匹配规则：支持通配符、多类型、大小写无关、事件与动作特殊匹配等场景，满足复杂的节点交互需求。\n- 递归处理多类型：通过拆分多类型并递归校验，实现灵活的 “任一类型匹配即可连接” 的逻辑。\n\n#### 使用场景\n该方法主要在框架内部用于判断节点间连接的合法性，例如：\n```\n// 示例1：类型完全匹配\nLiteGraph.isValidConnection(\"number\", \"number\"); // true\n\n// 示例2：通配符匹配\nLiteGraph.isValidConnection(\"*\", \"string\"); // true（通用输出匹配字符串输入）\n\n// 示例3：多类型匹配\nLiteGraph.isValidConnection(\"number,string\", \"string,boolean\"); // true（string 匹配）\n\n// 示例4：事件与动作匹配\nLiteGraph.isValidConnection(LiteGraph.EVENT, LiteGraph.ACTION); // true\n\n// 示例5：不兼容类型\nLiteGraph.isValidConnection(\"number\", \"boolean\"); // false\n\n\n```\n\n\n#### 注意事项\n- 多类型需用逗号分隔（如 \"type1,type2\"），且不支持空格（如 \"type1, type2\" 会被视为为包含空格的类型）。\n- 事件（EVENT）与动作（ACTION）的匹配是单向的（EVENT→ACTION 有效，反向无效）。\n- 大小写不敏感（\"Number\" 与 \"number\" 视为相同），但建议统一使用小写定义类型。\n该方法是保障节点网络数据流转正确性的核心逻辑，通过灵活的匹配规则平衡了严格性与易用性。"
          },
          "children": []
        },
        {
          "id": "f33086aa-16e8-4876-8054-bf5839ddbf96",
          "title": "registerSearchboxExtra",
          "path": "/308d3e53-0f85-4f3b-b2e1-e073bd0acf6f/f33086aa-16e8-4876-8054-bf5839ddbf96",
          "content": {
            "title": "registerSearchboxExtra",
            "content": "registerSearchboxExtra 方法注释分析\n该方法是 LiteGraph 框架中用于为搜索框注册推荐项的工具函数，作用是将特定节点类型与搜索关键词关联，当用户在搜索框输入相关文本时，框架会推荐该节点，提升用户查找节点的效率。\n方法功能概述\nregisterSearchboxExtra 用于向搜索框的推荐系统中添加一项关联记录，将节点类型与描述文本绑定。当用户在搜索框输入与描述文本相关的内容时，该节点会出现在推荐结果中，并显示对应的描述信息，支持附带配置数据以便快速创建节点时自动应用配置。\n参数说明\nnode_type（String）：\n推荐的节点类型全名（如 \"math/add\"），即用户选择该推荐项时，框架会创建该类型的节点。\ndescription（String）：\n搜索关键词及显示文本，用户输入与此文本相关的内容时，该节点会被推荐；同时该文本会显示在推荐结果中，帮助用户理解节点用途。\ndata（Object，可选）：\n节点的配置数据（如 { value: 0, pos: [100, 200] }），当基于此推荐项创建节点时，可自动应用这些配置。\n返回值说明\n原注释中提到返回 Boolean（是否可连接），但实际代码未返回值，推测为注释误差。该方法主要用于注册数据，无返回值。\n\n```\n/ * *\n* 如果两个槽的类型兼容（考虑通配符等）则返回\n* @方法isValidConnection\n* @param {String} type_a\n* @param {String} type_b\n* @返回{布尔}true如果它们可以连接\n* /\n   registerSearchboxExtra: function(node_type, description, data) {\n        this.searchbox_extras[description.toLowerCase()] = {\n            type: node_type,\n            desc: description,\n            data: data\n        };\n    },\n```\n\n核心实现逻辑\n方法通过将推荐项存储到 searchbox_extras 字典中实现注册：\njavascript\nthis.searchbox_extras[description.toLowerCase()] = {\n    type: node_type,       // 节点类型\n    desc: description,     // 显示的描述文本\n    data: data             // 附带的配置数据\n};\n\n以 description 的小写形式作为键（确保搜索时不区分大小写）；\n对应的值是一个对象，包含节点类型、原始描述文本和配置数据；\nsearchbox_extras 作为全局存储容器，供搜索框筛选推荐项时查询。\n关键作用\n增强搜索体验：通过手动注册关键词与节点的关联，补充自动索引的不足，确保重要节点能被用户快速找到。\n自定义推荐文本：允许为节点设置更友好的搜索关键词或描述（如为 \"math/sum\" 注册描述 \"add two numbers\"），提升搜索准确性。\n预配置节点：通过 data 参数携带配置信息，用户选择推荐项时可直接创建带有预设配置的节点，简化操作。\n使用场景\n适用于为节点添加自定义搜索推荐项，例如：\n```\n// 为 \"math/add\" 节点注册搜索推荐\nLiteGraph.registerSearchboxExtra(\n    \"math/add\",          // 节点类型\n    \"Add two numbers\",   // 搜索关键词及描述\n    { title: \"My Adder\" } // 预配置数据\n);\n```\n当用户在搜索框输入 \"add\"、\"numbers\" 等与描述相关的内容时，\"math/add\" 节点会出现在推荐结果中，显示文本为 \"Add two numbers\"，创建时自动应用 title: \"My Adder\" 配置。\n注意事项\n键为小写的 description，因此搜索时不区分大小写（如输入 \"ADD\" 也能匹配）。\n若多次注册相同的 description（小写后相同），后注册的项会覆盖前一项。\ndata 参数的内容需与节点类的属性兼容，否则创建节点时可能出现异常。\n该方法为节点搜索提供了灵活性，尤其适用于为复杂节点类型添加更直观的搜索入口。"
          },
          "children": []
        }
      ]
    }
  ]
}